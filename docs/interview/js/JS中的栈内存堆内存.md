JS的内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。
其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。
## 栈数据结构
栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。 栈被称为是一种**后入先出**（LIFO，last-in-first-out）的数据结构。 由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。 为了得到栈底的元素，必须先拿掉上面的元素。
在这里，为方便理解，通过类比乒乓球盒子来分析栈的存取方式。

PS: 后进先出，其中的先出，指的是垃圾回收，在编码的过程中，程序自上而下执行，嵌套越深的变量被出栈之后对程序的影响越小，嵌套越浅的变量（如全局变量）是不能轻易将数据从堆栈中取出的
## 堆数据结构
堆是一种经过排序的树形数据结构，每个结点都有一个值。 通常我们所说的堆的数据结构，是指二叉堆。 堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。 由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书， 虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书， 我们只需要关心书的名字。
## 变量类型与内存的关系
### 基本数据类型
基本数据类型共有6种：

1. Sting
2. Number
3. Boolean
4. null
5. undefined
6. Symbol

基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。
需要注意的是闭包中的基本数据类型变量不保存在栈内存中，而是保存在堆内存中。

### 引用数据类型
Array,Function,Object...可以认为除了上文提到的基本数据类型以外，所有类型都是引用数据类型。
引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体
![image.png](https://cdn.nlark.com/yuque/0/2021/png/292785/1639114756363-4a5358dc-dc1f-43df-9ee1-2de1ef4b22c9.png#clientId=udd73bb51-bfbd-4&from=paste&height=377&id=u8ba34961&name=image.png&originHeight=377&originWidth=653&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86874&status=done&style=none&taskId=ueb3588f8-de1b-4ec3-ade7-d818a86baca&title=&width=653)
因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量中获取了该对象的地址指针， 然后再从堆内存中取得我们需要的数据。

## 从内存角度来看变量复制
### 基本数据类型的复制
```javascript
let a = 20;
let b = a;
b = 30;
console.log(a); // 20
```
在这个例子中，a、b 都是基本类型，它们的值是存储在栈内存中的，a、b 分别有各自独立的栈空间， 所以修改了 b 的值以后，a 的值并不会发生变化。
### 引用数据类型的复制
```javascript
let m = { a: 10, b: 20 };
let n = m;
n.a = 15;
console.log(m.a) //此时m.a的值是15
```
在这个例子中，m、n都是引用类型，栈内存中存放地址指向堆内存中的对象， 引用类型的复制会为新的变量自动分配一个新的值保存在变量中， 但只是引用类型的一个地址指针而已，实际指向的是同一个对象， 所以修改 n.a 的值后，相应的 m.a 也就发生了改变。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/292785/1639114921853-a914d188-de90-4273-b5bd-dab0cbb49918.png#clientId=udd73bb51-bfbd-4&from=paste&height=701&id=ub1be4080&name=image.png&originHeight=701&originWidth=631&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112407&status=done&style=none&taskId=u6939f082-7546-4013-a5e2-1a5b2eb42bc&title=&width=631)
## 栈内存和堆内存的优缺点
在JS中，基本数据类型变量大小固定，并且操作简单容易，所以把它们放入栈中存储。 引用类型变量大小不固定，所以把它们分配给堆中，让他们申请空间的时候自己确定大小，这样把它们分开存储能够使得程序运行起来占用的内存最小。
栈内存由于它的特点，所以它的系统效率较高。 堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈。
## 栈内存和堆内存的垃圾回收
栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收， 而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。

## 闭包与堆内存
闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量。
```javascript
function A() {
  let a = 1;
  function B() {
      console.log(a);
  }
  return B;
}
let res = A();
```
函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。
函数 A 弹出调用栈后，函数 A 中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。 现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。

