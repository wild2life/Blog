import{_ as s,h as a,o as n,aa as p}from"./chunks/framework.ExfwmXLr.js";const h=JSON.parse('{"title":"综合考虑","description":"","frontmatter":{},"headers":[],"relativePath":"others/ts.md","filePath":"others/ts.md","lastUpdated":1731651584000}'),e={name:"others/ts.md"},l=p(`<p><a href="https://ts.xcatliu.com/introduction/index.html" target="_blank" rel="noreferrer">TS 入门</a> 专业流程平台 Vue+TypeScript 实践分享 项⽬是基于 BPMN 的规范来做的⼀个流程设计器，前端的技术框架基于 Vue，使⽤  TypeScript  来编写</p><p>什么是 TypeScript？ • TypeScript 是⼀种由微软开发的开源、跨平台的编程语⾔。它是 JavaScript 的超集，最终会被编译   为 JavaScript 代码。 • TypeScript 添加了可选的静态类型系统和很多尚未正式发布的 ECMAScript 新特性。 • TypeScript ⽀持任意浏览器，任意环境，任意系统并且是开源的。</p><p>优缺点:</p><h2 id="优点" tabindex="-1">优点： <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点：&quot;">​</a></h2><h3 id="_1-静态类型" tabindex="-1">1.静态类型 <a class="header-anchor" href="#_1-静态类型" aria-label="Permalink to &quot;1.静态类型&quot;">​</a></h3><p>我们都知道，JavaScript 是⼀个弱类型，且是动态类型的脚本语⾔，什么变量都可以 var ⼀下，变     量还可以随便赋值，函数的返回值也可以是任意类型。导致代码报错是在运⾏阶段，⽽ TypeScript 则是静态类型，如果出错在代码编译时边会提⽰报错。 <img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003563445-15698601-8168-4e40-abdd-649813cfbab1.png#align=left&amp;display=inline&amp;height=1160&amp;name=image.png&amp;originHeight=1160&amp;originWidth=1734&amp;size=1218046&amp;status=done&amp;style=none&amp;width=1734" alt="image.png"></p><h3 id="_2-方便阅读" tabindex="-1">2.⽅便阅读 <a class="header-anchor" href="#_2-方便阅读" aria-label="Permalink to &quot;2.⽅便阅读&quot;">​</a></h3><p>类型系统实际上也是⼀个⾮常实⽤的⽂档，⼤部分的函数通过查看类型的定义就可以知道如何使 ⽤，并且在 VSCode（此处使⽤ VSCode 来代表所有代码编辑器）⾥⾯去编写 TypeScript 时，VSCode  会根据你当前的上下⽂，把你能⽤的类、变量、⽅法和关键字都提⽰出来，⼀⽬了然。不仅如此， TypeScript 的特性还增强了 VSCode 的功能，包括代码补全、接⼝提⽰和点击跳转等等 如下图，我们可以很清晰的通过⿏标选中查看其属性的数据结构：  <img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003670578-92a4f5b0-e391-4db4-a508-5e95e2e20d0d.png#align=left&amp;display=inline&amp;height=655&amp;name=image.png&amp;originHeight=1310&amp;originWidth=1728&amp;size=3097384&amp;status=done&amp;style=none&amp;width=864" alt="image.png"></p><h3 id="_3-减少-bug" tabindex="-1">3. 减少 bug <a class="header-anchor" href="#_3-减少-bug" aria-label="Permalink to &quot;3. 减少 bug&quot;">​</a></h3><p>随着的项⽬的迭代，我们可能会常常遗忘该变量或者函数的返回值类型，再加之 JavaScript 本⾝       具有的隐式转化，让我们对类型的判断更加的困难，难以控制。后期回顾数据类型⼤⼤影响开发效率，这⾥要加⼀个类型判断，那⾥也要进⾏⼀次类型转换。 如下图中，TypeScript 的类型推断，可以让我们在编码时候⽴即发现⾃⼰的类型错误。我们已经     看到了 VSCode 等 IDE 都会做出类型检查，可以将很多类型错误直接提⽰出来，这⼀点在多⼈开发，和      维护⼤型项⽬时尤为重要。项⽬复杂，函数和变量繁多时经常出现⼀个⼈改了⼀点点东西，导致项⽬崩溃的情况，在 TypeScript 上⾯这种情况会⼤⼤减少。 但是值得注意的是，使⽤ TypeScript 也只能避免⼀部分错误，不能⼀劳永逸，平时遵守严格的编      码规范，配置 ESLint，代码 review，以及编写单元测试等环节依然很重要！</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003688968-f3ea0cd7-11cf-4eac-b5aa-95301eb21707.png#align=left&amp;display=inline&amp;height=293&amp;name=image.png&amp;originHeight=586&amp;originWidth=1862&amp;size=782017&amp;status=done&amp;style=none&amp;width=931" alt="image.png"></p><h3 id="_4-社区活跃" tabindex="-1">4.  社区活跃 <a class="header-anchor" href="#_4-社区活跃" aria-label="Permalink to &quot;4.  社区活跃&quot;">​</a></h3><p>继 Angular 之后，React，Vue 都相继开始⽀持 TypeScript，尤其是 2019 年更是 TypeScript 爆发性       增⻓的⼀年，⼤部分第三⽅库都开始有提供给 TypeScript 的类型定义⽂件。</p><h2 id="缺点" tabindex="-1">缺点： <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点：&quot;">​</a></h2><h3 id="_1-学习成本" tabindex="-1">1.  学习成本 <a class="header-anchor" href="#_1-学习成本" aria-label="Permalink to &quot;1.  学习成本&quot;">​</a></h3><p><a href="https://juejin.im/post/5edd8ad8f265da76fc45362c#heading-52" target="_blank" rel="noreferrer">了不起的  TypeScript  ⼊⻔教程</a> TypeScript 因为是在 JavaScript 的基础上扩展，所以真正的学习成本并不⼤，但毕竟是静态类      型，⽽且需要理解接⼝、泛型、类、枚举类型新的概念，对于习惯了 JavaScript 语⾔的⼈来说很难习        惯，导致了很多同学听⻅ TypeScript 的第⼀反应都是拒绝，尤其是在看了⽤ TypeScript 编写的项⽬      后。⽽且如果你想要在现有项⽬中充分体验 TypeScript，你⼜将⾯临异常⾼昂的切换成本。</p><h3 id="_2-开发速度降低" tabindex="-1">2. 开发速度降低 <a class="header-anchor" href="#_2-开发速度降低" aria-label="Permalink to &quot;2. 开发速度降低&quot;">​</a></h3><p>虽然 TypeScript 提供了 any 类型，但是使⽤它的同时也失去了 TypeScript 的优势，建议尽量少使⽤。虽然类型系统⾃带⽂档，可以省去很多编写注释的时间，但是为所有值填上类型过程有点痛苦。 我们每⼀个数据对象都需要先定义好数据类型，从⽽在需要的是要导⼊引⽤进⾏约束变量或者函数返 回值，如下图所⽰。接⼝定义：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003787460-bd496c1a-c372-4cdb-8d82-ac2301b67d19.png#align=left&amp;display=inline&amp;height=539&amp;name=image.png&amp;originHeight=1078&amp;originWidth=1708&amp;size=1922355&amp;status=done&amp;style=none&amp;width=854" alt="image.png"></p><p>接⼝引⼊：  <img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003809285-64b05a5e-5517-45ff-a364-030cbd0b7928.png#align=left&amp;display=inline&amp;height=417&amp;name=image.png&amp;originHeight=834&amp;originWidth=1668&amp;size=1249396&amp;status=done&amp;style=none&amp;width=834" alt="image.png"></p><h3 id="_3-部分第三方库的兼容" tabindex="-1">3.  部分第三⽅库的兼容 <a class="header-anchor" href="#_3-部分第三方库的兼容" aria-label="Permalink to &quot;3.  部分第三⽅库的兼容&quot;">​</a></h3><p>随着 TypeScript 的愈加⽕爆，很多依赖包都⽀持了 TypeScript，但是依然有⼀部分还没有⽀持，如果你的项⽬刚好依赖了它们⽽你还想使⽤ TypeScript 的话，那你就需要为他添加⼀个 d.ts ⽂件才可以使⽤，添加的过程较为⿇烦.</p><h3 id="_4-需要编译" tabindex="-1">4.  需要编译 <a class="header-anchor" href="#_4-需要编译" aria-label="Permalink to &quot;4.  需要编译&quot;">​</a></h3><p>JavaScript 是标准，是可以直接在浏览器运⾏的，但 TypeScript 不能直接运⾏需要经过编译，⽣成 JavaScript 才可以运⾏。</p><h2 id="我们对-typescript-的使用" tabindex="-1">我们对 TypeScript 的使⽤ <a class="header-anchor" href="#我们对-typescript-的使用" aria-label="Permalink to &quot;我们对 TypeScript 的使⽤&quot;">​</a></h2><h3 id="_1-类型约束" tabindex="-1">1.   类型约束 <a class="header-anchor" href="#_1-类型约束" aria-label="Permalink to &quot;1.   类型约束&quot;">​</a></h3><p>对已确定的数据结构定义接⼝，在定义或者引⽤相同数据结构时引⽤接⼝类型约束，防⽌数据类型赋值和函数返回值错误。 <img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003850142-0c75142f-45bb-4934-9350-e4f220068947.png#align=left&amp;display=inline&amp;height=566&amp;name=image.png&amp;originHeight=1132&amp;originWidth=1644&amp;size=1380264&amp;status=done&amp;style=none&amp;width=822" alt="image.png"></p><h3 id="_2-枚举定义" tabindex="-1">2.   枚举定义 <a class="header-anchor" href="#_2-枚举定义" aria-label="Permalink to &quot;2.   枚举定义&quot;">​</a></h3><p>对⼀些固定值使⽤枚举定义，可以在让其他同学在阅读代码、后期维护时可以⻅名知意，降低阅读代码成本。enum 类型是对 JavaScript 标准数据类型的⼀个补充。    像 C#等其它语⾔⼀样，使⽤枚举类型可以为⼀组数字或字符串赋予友好的名字。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003876216-63978e29-faed-4ce3-a233-cf3338e22b0e.png#align=left&amp;display=inline&amp;height=364&amp;name=image.png&amp;originHeight=728&amp;originWidth=1696&amp;size=690338&amp;status=done&amp;style=none&amp;width=848" alt="image.png"></p><h3 id="_3-bpmn-解析模式" tabindex="-1">3.   BPMN 解析模式 <a class="header-anchor" href="#_3-bpmn-解析模式" aria-label="Permalink to &quot;3.   BPMN 解析模式&quot;">​</a></h3><p>我们在 bpmn.js 本⾝⾃⾝ api 解析对象与 Vue 的 data 层之间建⽴了⼀层数据解析层，并且会根据 Vue  所需的 data 层数据结构对每个 bpmn 结构元素设计出较为合理的数据结构，以便于视图层渲染和复⽤。在此解析层所有的数据都会预先在 typing.fixflow.d.ts ⽂件中定义好，⽤来约束解析出来的结果是我们所必须数据结构。这样的设计可以避免⼀些数据层级过深导致某些属性解析缺失，或者在后期迭代的过程中数据结构变更，⽽未能将所有的引⽤更替。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003923670-0f205e05-adfb-4fdd-94bc-7cf43b523f6f.png#align=left&amp;display=inline&amp;height=735&amp;name=image.png&amp;originHeight=1470&amp;originWidth=2120&amp;size=2645828&amp;status=done&amp;style=none&amp;width=1060" alt="image.png"></p><h3 id="_4-class-style" tabindex="-1">4.   class-style <a class="header-anchor" href="#_4-class-style" aria-label="Permalink to &quot;4.   class-style&quot;">​</a></h3><p>由于 vue 对 typescript ⽀持的装饰器(库)，本项⽬引⽤ vue-property-decorator(依赖 vue-class- component)进⾏组件编写。通过该插件可以使⽤类的写法替换原本组件的对象写法，让组件的编写      更为优雅。 <img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608003972539-d387ec9e-f282-49b3-bf73-238cfd131c17.png#align=left&amp;display=inline&amp;height=778&amp;name=image.png&amp;originHeight=1556&amp;originWidth=2082&amp;size=2533701&amp;status=done&amp;style=none&amp;width=1041" alt="image.png"></p><h3 id="_5-props-类型约定" tabindex="-1">5. Props 类型约定 <a class="header-anchor" href="#_5-props-类型约定" aria-label="Permalink to &quot;5. Props 类型约定&quot;">​</a></h3><p>在封装组件时候会对传⼊的值进⾏类型约定，可以尽量避免因传⼊的值数据结构与组件内部处理不 ⼀致，导致组件内渲染出错。  <img src="https://cdn.nlark.com/yuque/0/2020/png/292785/1608004038846-0941f56c-7dd4-4f42-9d52-48519d46c31c.png#align=left&amp;display=inline&amp;height=626&amp;name=image.png&amp;originHeight=1252&amp;originWidth=2308&amp;size=2384614&amp;status=done&amp;style=none&amp;width=1154" alt="image.png"></p><h3 id="_6-不足" tabindex="-1">6.     不⾜ <a class="header-anchor" href="#_6-不足" aria-label="Permalink to &quot;6.     不⾜&quot;">​</a></h3><p>a.        许多地⽅没有使⽤ TS 的新特性</p><p>b.        依旧有许多地⽅使⽤ any 类型</p><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h3><h4 id="函数重载" tabindex="-1">函数重载 <a class="header-anchor" href="#函数重载" aria-label="Permalink to &quot;函数重载&quot;">​</a></h4><h5 id="_2-个或-2-个以上的同名普通函数-但参数不一样-这时会出现函数重载的情况。ts-中重载-通过为一个函数提供多个函数类型定义走多种功能目的" tabindex="-1">2 个或 2 个以上的同名普通函数，但参数不⼀样，这时会出现函数重载的情况。TS 中重载,通过为⼀个函数提供多个函数类型定义⾛多种功能⽬的 <a class="header-anchor" href="#_2-个或-2-个以上的同名普通函数-但参数不一样-这时会出现函数重载的情况。ts-中重载-通过为一个函数提供多个函数类型定义走多种功能目的" aria-label="Permalink to &quot;2 个或 2 个以上的同名普通函数，但参数不⼀样，这时会出现函数重载的情况。TS 中重载,通过为⼀个函数提供多个函数类型定义⾛多种功能⽬的&quot;">​</a></h5><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 普通js</span></span>
<span class="line"><span>function css(config){}</span></span>
<span class="line"><span>function css(config, value){} // 会替换上⾯的⽅法</span></span>
<span class="line"><span>// TS 中</span></span>
<span class="line"><span>function getInfo(name: string): string{}</span></span>
<span class="line"><span>function getInfo(age: number): number{}</span></span>
<span class="line"><span>function getInfo(str: any): any{} // 根据参数不同，⾛不同逻辑</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="类里面的三种修饰符" tabindex="-1">类⾥⾯的三种修饰符 <a class="header-anchor" href="#类里面的三种修饰符" aria-label="Permalink to &quot;类⾥⾯的三种修饰符&quot;">​</a></h4><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public 共有 类内部、⼦类、类外部都可以访问</span></span>
<span class="line"><span>protected 保护 类⾥、⼦类可以访问，类外部不可以访问</span></span>
<span class="line"><span>private 私有 类⾥可以访问，⼦类和类外不可访问</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="ts-抽象类-提供给其他类继承的基础类-必须实现抽象类继承-否则报错" tabindex="-1">TS 抽象类：提供给其他类继承的基础类，必须实现抽象类继承，否则报错 <a class="header-anchor" href="#ts-抽象类-提供给其他类继承的基础类-必须实现抽象类继承-否则报错" aria-label="Permalink to &quot;TS 抽象类：提供给其他类继承的基础类，必须实现抽象类继承，否则报错&quot;">​</a></h4><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>abstract class Animal { // 基类</span></span>
<span class="line"><span>	public name: string;</span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>  	this.name = name;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  abstract eat():any; // 定义⽅法</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>class Cat extends Animal {</span></span>
<span class="line"><span>  constructor(name: any) {</span></span>
<span class="line"><span>  	super(name)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  eat() {</span></span>
<span class="line"><span>  	xxxx</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var c = new Cat(&#39;name&#39;)</span></span>
<span class="line"><span>c.eat() // 必须调⽤定义⽅法，否则报错</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h4 id="接口的概念-对-json-约束" tabindex="-1">接⼝的概念：对 JSON 约束 <a class="header-anchor" href="#接口的概念-对-json-约束" aria-label="Permalink to &quot;接⼝的概念：对 JSON 约束&quot;">​</a></h4><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface FullName {</span></span>
<span class="line"><span>  firstName: string;</span></span>
<span class="line"><span>  lastName: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>function printName(name: FullName) { // FullName 对应上⾯定义</span></span>
<span class="line"><span>	console.log(name. firstName + name. lastName)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="加密函数类型接口" tabindex="-1">加密函数类型接⼝ <a class="header-anchor" href="#加密函数类型接口" aria-label="Permalink to &quot;加密函数类型接⼝&quot;">​</a></h4><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface encrypt {</span></span>
<span class="line"><span>	(key: string, value: string): string // 约束函数：传值和返回值，可做批量约束</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var md5: encrypt = function(key: string, value: string):string {</span></span>
<span class="line"><span>	return key + value;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>md5(&#39;name&#39;, &#39;zhangsan&#39;)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="类-类型接口-常用-类似于抽象类" tabindex="-1">&#39;类&#39;类型接⼝，常⽤，类似于抽象类 <a class="header-anchor" href="#类-类型接口-常用-类似于抽象类" aria-label="Permalink to &quot;&#39;类&#39;类型接⼝，常⽤，类似于抽象类&quot;">​</a></h4><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Animal { // 实现这个接⼝，必须有name和eat这个标准</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  eat(str: string):void;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>class Dog implements Animal {</span></span>
<span class="line"><span>	name: string; // 必须存在</span></span>
<span class="line"><span>  constructor(name: string) {</span></span>
<span class="line"><span>  this.name = name</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  eat() { // 必须存在</span></span>
<span class="line"><span>  		11 xxxx 12</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var d = new Dog(&#39;wang&#39;)</span></span>
<span class="line"><span>d.eat()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="接口的继承" tabindex="-1">接⼝的继承 <a class="header-anchor" href="#接口的继承" aria-label="Permalink to &quot;接⼝的继承&quot;">​</a></h4><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Animal {</span></span>
<span class="line"><span>	eat():void</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>interface Person extends Animal {</span></span>
<span class="line"><span>	work():void</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span> // 接⼝继承接⼝</span></span>
<span class="line"><span> class Web implements Person {</span></span>
<span class="line"><span>   public name: string;</span></span>
<span class="line"><span>   constructor(name: string) {</span></span>
<span class="line"><span>   		this.name = name</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   eat(){ xxx }</span></span>
<span class="line"><span>   work() { xxx }</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span> class Programer {</span></span>
<span class="line"><span>   constructor(name: string) {</span></span>
<span class="line"><span>   		super(name)</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>   coding() { xxx }</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>// extends继承普通构造函数可以直接调⽤私有函数coding</span></span>
<span class="line"><span>// implements配合interface接⼝，定义eat和wrok⽅法</span></span>
<span class="line"><span>class Web extends Programer implements Person {</span></span>
<span class="line"><span>	constructor(name: string) {</span></span>
<span class="line"><span>  	super(name)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  eat(){ xxx }</span></span>
<span class="line"><span>  work() { xxx }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h4 id="interface-与-type-区别" tabindex="-1">interface  与  type  区别 <a class="header-anchor" href="#interface-与-type-区别" aria-label="Permalink to &quot;interface  与  type  区别&quot;">​</a></h4><p><a href="https://juejin.im/post/5c2723635188252d1d34dc7d#heading-11" target="_blank" rel="noreferrer">Typescript  中的  interface  和  type  到底有什么区别</a> 相同点： a.        都可以描述⼀个对象或者函数 b.        都允许拓展（extends） c.         都可以被类实现（implements）   不同点：</p><p>a.       type  可以声明基本类型别名，联合类型，元组等类型 b.       interface  能够声明合并</p><h4 id="泛型-可以支持不特定的数据类型-要求-传入的参数和返回的参数必须一致" tabindex="-1">泛型：可以⽀持不特定的数据类型，要求：传⼊的参数和返回的参数必须⼀致 <a class="header-anchor" href="#泛型-可以支持不特定的数据类型-要求-传入的参数和返回的参数必须一致" aria-label="Permalink to &quot;泛型：可以⽀持不特定的数据类型，要求：传⼊的参数和返回的参数必须⼀致&quot;">​</a></h4><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span> function getData&lt;T&gt;(value: T):T {</span></span>
<span class="line"><span> 		return value // 返回值也必须是定义类型T</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span> getData&lt;string&gt;(&#39;12345&#39;) // T是string，所以传参也必须是字符串</span></span>
<span class="line"><span> getData&lt;number&gt;(&#39;12345&#39;) // T是number，所以传参不是字符串，报错</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="泛型类-最小堆算法" tabindex="-1">泛型类：最⼩堆算法 <a class="header-anchor" href="#泛型类-最小堆算法" aria-label="Permalink to &quot;泛型类：最⼩堆算法&quot;">​</a></h4><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class MinClass&lt;T&gt; {</span></span>
<span class="line"><span>  public list:T[] = [];</span></span>
<span class="line"><span>  add(value: T):void {</span></span>
<span class="line"><span>  	this.list.push(value)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  min():T {</span></span>
<span class="line"><span>    var minNum = this.list[0]</span></span>
<span class="line"><span>    return minNum</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var m1 = new MinClass&lt;number&gt;() // 定义T为number类型</span></span>
<span class="line"><span>m1.add(1)// 传参也为数字类型</span></span>
<span class="line"><span>mi.min()// 返回值也为数字类型</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="泛型接口" tabindex="-1">泛型接⼝ <a class="header-anchor" href="#泛型接口" aria-label="Permalink to &quot;泛型接⼝&quot;">​</a></h4><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 第⼀种写法：</span></span>
<span class="line"><span>interface config {</span></span>
<span class="line"><span>	&lt;T&gt;(value:T):T;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var getData:config = function&lt;T&gt;(value:T):T {</span></span>
<span class="line"><span>	return value</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>getData&lt;string&gt;(&#39;张三&#39;) // 通过</span></span>
<span class="line"><span>getData&lt;string&gt;(123) //报错</span></span>
<span class="line"><span>// 第⼆种写法：</span></span>
<span class="line"><span>interface config&lt;T&gt; {</span></span>
<span class="line"><span>	(value:T):T;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>function getData(T)(value:T):T {</span></span>
<span class="line"><span>	return value</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var myData:config&lt;string&gt; = getData</span></span>
<span class="line"><span>myData(&#39;abc&#39;) // 通过</span></span>
<span class="line"><span>myData(123) // 报错</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h4 id="类型编程" tabindex="-1">类型编程 <a class="header-anchor" href="#类型编程" aria-label="Permalink to &quot;类型编程&quot;">​</a></h4><h5 id="typescript-进阶⸺类型编程-通过-typescript-操作符-把类型当作参数进行逻辑处理-从而获得新的类型的过程称为类型编程。其中大部分都是通过泛型来引入-因此泛型是-ts-类型编程的基础。" tabindex="-1">（   <a href="https://bytedance.feishu.cn/docs/doccnFqnqcIlHHa6TGqukjD9zAh" target="_blank" rel="noreferrer">TypeScript   进阶⸺类型编程</a>）：通过 TypeScript 操作符，把类型当作参数进⾏逻辑处理，从⽽获得新的类型的过程称为类型编程。其中⼤部分都是通过泛型来引⼊，因此泛型是 TS 类型编程的基础。 <a class="header-anchor" href="#typescript-进阶⸺类型编程-通过-typescript-操作符-把类型当作参数进行逻辑处理-从而获得新的类型的过程称为类型编程。其中大部分都是通过泛型来引入-因此泛型是-ts-类型编程的基础。" aria-label="Permalink to &quot;（   [TypeScript   进阶⸺类型编程](https://bytedance.feishu.cn/docs/doccnFqnqcIlHHa6TGqukjD9zAh)）：通过 TypeScript 操作符，把类型当作参数进⾏逻辑处理，从⽽获得新的类型的过程称为类型编程。其中⼤部分都是通过泛型来引⼊，因此泛型是 TS 类型编程的基础。&quot;">​</a></h5><h4 id="声明类型参数有三种-泛型-、in-映射、infer-待推断" tabindex="-1">声明类型参数有三种：泛型&lt;&gt;、in 映射、infer 待推断 <a class="header-anchor" href="#声明类型参数有三种-泛型-、in-映射、infer-待推断" aria-label="Permalink to &quot;声明类型参数有三种：泛型&lt;&gt;、in 映射、infer 待推断&quot;">​</a></h4><h4 id="同态转换-同态转换会复制原有的所有属性的所有修饰词-在此基础上允许额外的增加新的属性修饰词。两个代数结构保持了结构不变的映射-则称这两个代数结构是同态的。ts-中类型索引和类型映射-是同态的。" tabindex="-1">同态转换：同态转换会复制原有的所有属性的所有修饰词，在此基础上允许额外的增加新的属性修饰词。两个代数结构保持了结构不变的映射，则称这两个代数结构是同态的。TS 中类型索引和类型映射           是同态的。 <a class="header-anchor" href="#同态转换-同态转换会复制原有的所有属性的所有修饰词-在此基础上允许额外的增加新的属性修饰词。两个代数结构保持了结构不变的映射-则称这两个代数结构是同态的。ts-中类型索引和类型映射-是同态的。" aria-label="Permalink to &quot;同态转换：同态转换会复制原有的所有属性的所有修饰词，在此基础上允许额外的增加新的属性修饰词。两个代数结构保持了结构不变的映射，则称这两个代数结构是同态的。TS 中类型索引和类型映射           是同态的。&quot;">​</a></h4><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span> type Common&lt;T&gt; = { [K in keyof T]: T[K] }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>条件分布式 当满⾜条件， a.        存在联合类型作为输⼊ b.        有条件运算 extends c.         联合类型所指的⼊参必须是裸类型（没有被其他类型包裹）</p><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>(A | B | C) extends U ? X : Y = (A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</span></span>
<span class="line"><span>(A &amp; B &amp; C) extends U ? X : Y = (A extends U ? X : Y) &amp; (B extends U ? X : Y) &amp; (C extends U ? X : Y)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>官⽅类型递归例⼦：</p><div class="language-basic vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">basic</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span> type LinkedList&lt;T&gt; = T &amp; { next: LinkedList&lt;T&gt; };</span></span>
<span class="line"><span>class Person {</span></span>
<span class="line"><span>	name: string</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>let people: LinkedList&lt;Person&gt;;</span></span>
<span class="line"><span>let s = people.name;</span></span>
<span class="line"><span>let s = people.next.name;</span></span>
<span class="line"><span>let s = people.next.next.name;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h1 id="综合考虑" tabindex="-1">综合考虑 <a class="header-anchor" href="#综合考虑" aria-label="Permalink to &quot;综合考虑&quot;">​</a></h1><p>在开始专业流程平台项⽬之前我们主要是基于以下⼏点考虑 1.        新项⽬。从头开发，没有重构⽼代码的成本。</p><p>2.        对新技术的尝试。组内⼈员对新技术的热忱度都很⾼，希望通过⼀个项⽬来实践 TypeScript。 3.        多⼈协作。专业流程平台项⽬庞⼤，且 BPMN ⽂件解析的数据需要来回传递和修改。 4.        不同功能模块之间数据获取和传递。对于类型系统的需求⼤，每个⼈来编写时都可以避免类型错误，并且⽅便获取参数类型进⾏操作。 5.        代码规范化。所以代码越规范越好，TypeScript 便于理解，并配有详细的注释。 6.        接⼝返回值固定类型。可以更好的进⾏类型推断。 7.        项⽬持续迭代和维护。使⽤ TypeScript 可以⽅便⼤家阅读和后续扩展、重构。</p><h1 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h1><p>个⼈认为专业流程平台项⽬接⼊ TypeScript 是⼀个⾮常好的技术⽅案，⽽且从  Vue2.5  之后，Vue  对  TypeScript 有更好的⽀持。在本项⽬的实践开发过程中，我觉得以下⼏点是需要注意并遵守的： a.        对定义的变量、参数以及函数的返回值进⾏接⼝类型约束 b.        对与⼀些需要固定的值，可以使⽤枚举给其⻅名知意的变量名 c.         在使⽤ class ⻛格封装组件时候，我们在 props 传值时需要对传⼊组件内部值进⾏类型约定 d.        能不⽤ any 类型定义变量类型时，我们则不⽤ e.        我们尽量使⽤ TS 带了的新特性，让代码更为的优雅，例如：可选链  ?. 、双问号操作符  ??  等</p><p>是否使⽤ TypeScript，我们认为在做出选择之前，你需要认真的衡量⼀下投⼊产出⽐， TypeScript 带来的优势是否对当前的项⽬有很⼤提升，是否值得花费⼤量的时间去对现有项⽬进⾏重       构，值得注意的⼀点是，不管 TypeScript 最终会不会被应⽤到项⽬中，你都应该学会掌握它。 最后，对于取舍问题，我们感觉是：如果你的项⽬是⼤型项⽬，第三⽅库，或者其他需要持续维护的项⽬，上 TypeScript 吧；如果你的项⽬是活动，分享⻚⾯，等短周期并且不需要持续维护的项 ⽬，想⽤哪个⽤哪个。</p><h1 id="视频回顾" tabindex="-1">视频回顾 <a class="header-anchor" href="#视频回顾" aria-label="Permalink to &quot;视频回顾&quot;">​</a></h1><p><a href="https://www.feishu.cn/space/file/boxcnNIDZfaPYLA1u1IML2NVC7U" target="_blank" rel="noreferrer">专业流程平台 Vue+TypeScript 实践分享.mp4</a><a href="https://www.yuque.com/attachments/yuque/0/2020/pdf/292785/1608013141405-43111e8e-88ff-4ba7-b1bc-b53437308737.pdf" target="_blank" rel="noreferrer">专业流程平台 Vue+TypeScript 实践分享.pdf</a></p><h4 id="ts-小技巧" tabindex="-1">ts 小技巧 <a class="header-anchor" href="#ts-小技巧" aria-label="Permalink to &quot;ts 小技巧&quot;">​</a></h4><p><a href="https://cy188.github.io/2021/04/09/2-TypeScript%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3-4.2/" target="_blank" rel="noreferrer">中文文档</a></p><p><strong>Partial</strong> 将传入的属性变为可选项</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface IPeople {</span></span>
<span class="line"><span>    title: string;</span></span>
<span class="line"><span>    name: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const people: Partial&lt;IPeople&gt; = {</span></span>
<span class="line"><span>    title: &#39;Delete inactive users&#39;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>Record&lt;K, T&gt;</strong> 类型参数 K 提供了对象属性名联合类型，类型参数 T 提供了对象属性的类型</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 将x, y 作为Person的key</span></span>
<span class="line"><span>type Peoples = Record&lt;&quot;x&quot; | &quot;y&quot;, Person&gt;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const P: Peoples = {</span></span>
<span class="line"><span>    x: {</span></span>
<span class="line"><span>        name: &#39;张三&#39;</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    y: {</span></span>
<span class="line"><span>        name: &#39;李四&#39;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>**Readonly ** 把传入的类型变为只读状态</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>  name: string;</span></span>
<span class="line"><span>  age: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const p: Readonly&lt;Person&gt; = {</span></span>
<span class="line"><span>    name: &#39;张三&#39;,</span></span>
<span class="line"><span>    age: 22</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>p.name = &#39;李四&#39;; // 无法分配到 &quot;name&quot; ，因为它是只读属性</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>Required</strong> 把传入的类型变为必填状态</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface Person {</span></span>
<span class="line"><span>    name?: string;</span></span>
<span class="line"><span>    age?: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const p: Required&lt;Person&gt; = {</span></span>
<span class="line"><span>    name: &#39;张三&#39;,</span></span>
<span class="line"><span>    age: 22</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>Pick&lt;T, S&gt;</strong> 在 T 中，过滤掉非 S 的类型</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface IPerson {</span></span>
<span class="line"><span>    name: string;</span></span>
<span class="line"><span>    age: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type TP = Pick&lt;IPerson, &#39;name&#39;&gt;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const p: TP = {</span></span>
<span class="line"><span>    age: 22, // 对象文字可以只指定已知属性，并且“age”不在类型“TP”中</span></span>
<span class="line"><span>    name: &#39;张三&#39;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>Omit&lt;T, K&gt;</strong> 在 T 中删除对应的 K</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>interface IPerson {</span></span>
<span class="line"><span>    name: string;</span></span>
<span class="line"><span>    age: number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type TP = Omit&lt;IPerson, &#39;age&#39;&gt;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const p: TP = {</span></span>
<span class="line"><span>    name: &#39;张三&#39;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>Exclude&lt;T, U&gt;</strong> 该工具类型能够从类型 T 中剔除所有可以赋值给类型 U 的类型</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type T0 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;;</span></span>
<span class="line"><span>// 相当于 type T0 = &quot;b&quot; | &quot;c&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;;</span></span>
<span class="line"><span>// 相当于 type T1 = &quot;c&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;;</span></span>
<span class="line"><span>// 相当于 type T2 = string | number</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>Extract&lt;T, U&gt;</strong> “Extract&lt;T, U&gt;”工具类型与“Exclude&lt;T, U&gt;”工具类型是互补的，它能够从类型 T 中获取所有可以赋值给类型 U 的类型</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type T0 = Extract&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39;, &#39;a&#39; | &#39;f&#39;&gt;;</span></span>
<span class="line"><span>// 相当于 type T0 = &#39;a&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type T1 = Extract&lt;string | (() =&gt; void), Function&gt;;</span></span>
<span class="line"><span>// 相当于 type T1 = () =&gt; void;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type T2 = Extract&lt;string | number, boolean&gt;;</span></span>
<span class="line"><span>// 因为没有交集，相当于 type T2 = never;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>ReturnType</strong> 该工具类型能够获取函数类型 T 的返回值类型</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// string</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReturnType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// { a: string; b: number }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReturnType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>`,102),i=[l];function r(t,c,b,u,m,o){return n(),a("div",null,i)}const g=s(e,[["render",r]]);export{h as __pageData,g as default};
