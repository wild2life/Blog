import{_ as a,h as i,o as e,aa as t}from"./chunks/framework.ExfwmXLr.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"others/内存管理.md","filePath":"others/内存管理.md","lastUpdated":1731651584000}'),l={name:"others/内存管理.md"},o=t('<p>减少浏览器的负担</p><p>JS 的内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。</p><h2 id="内存" tabindex="-1">内存 <a class="header-anchor" href="#内存" aria-label="Permalink to &quot;内存&quot;">​</a></h2><p>基本类型</p><ol><li>Sting</li><li>Number</li><li>Boolean</li><li>null</li><li>undefined</li><li>Symbol</li></ol><h3 id="栈内存" tabindex="-1">栈内存 <a class="header-anchor" href="#栈内存" aria-label="Permalink to &quot;栈内存&quot;">​</a></h3><h6 id="连续-普通类型存储-值和变量本身放在一起" tabindex="-1">连续 普通类型存储 值和变量本身放在一起 <a class="header-anchor" href="#连续-普通类型存储-值和变量本身放在一起" aria-label="Permalink to &quot;连续 普通类型存储 值和变量本身放在一起&quot;">​</a></h6><p>基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据</p><h3 id="" tabindex="-1"><img src="https://cdn.nlark.com/yuque/0/2021/png/292785/1638255699478-a017607b-2eb2-41f2-a804-d2b214825e06.png#clientId=u0af62612-21ca-4&amp;from=paste&amp;height=479&amp;id=u6ba7b618&amp;name=image.png&amp;originHeight=958&amp;originWidth=1574&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=145914&amp;status=done&amp;style=none&amp;taskId=ubdcfa520-872d-4861-99c5-3d7c9d947cf&amp;title=&amp;width=787" alt="image.png"> <a class="header-anchor" href="#" aria-label="Permalink to &quot;![image.png](https://cdn.nlark.com/yuque/0/2021/png/292785/1638255699478-a017607b-2eb2-41f2-a804-d2b214825e06.png#clientId=u0af62612-21ca-4&amp;from=paste&amp;height=479&amp;id=u6ba7b618&amp;name=image.png&amp;originHeight=958&amp;originWidth=1574&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=145914&amp;status=done&amp;style=none&amp;taskId=ubdcfa520-872d-4861-99c5-3d7c9d947cf&amp;title=&amp;width=787)&quot;">​</a></h3><h3 id="堆内存" tabindex="-1">堆内存 <a class="header-anchor" href="#堆内存" aria-label="Permalink to &quot;堆内存&quot;">​</a></h3><p>不连续 对象本身会放在堆内存里面 变量本身放在栈内存里 指向堆内存的地址</p><p>Array,Function,Object...可以认为除了上文提到的基本数据类型以外，所有类型都是引用数据类型。 引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 rensh <img src="https://cdn.nlark.com/yuque/0/2021/png/292785/1638255610108-322cc87b-2d1c-47e3-9cab-19874c2cb5ef.png#clientId=u0af62612-21ca-4&amp;from=paste&amp;height=634&amp;id=u5096330c&amp;name=image.png&amp;originHeight=1268&amp;originWidth=2366&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=758225&amp;status=done&amp;style=none&amp;taskId=u17f21f55-3864-4598-b82e-dc78c93ad2d&amp;title=&amp;width=1183" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/292785/1639114497763-2871c89a-5862-4bde-8977-0aa2e1b89271.png#clientId=u0cf11d8e-aa02-4&amp;from=paste&amp;height=377&amp;id=ub421448c&amp;name=image.png&amp;originHeight=377&amp;originWidth=653&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=86874&amp;status=done&amp;style=none&amp;taskId=u5817c86d-d784-46b2-b5bb-4e717e14dcd&amp;title=&amp;width=653" alt="image.png"></p><h2 id="认识-v8" tabindex="-1">认识 V8 <a class="header-anchor" href="#认识-v8" aria-label="Permalink to &quot;认识 V8&quot;">​</a></h2><ul><li>V8 —— 是 Google 发布的主流的开源 JavaScript 引擎，采用 C++ 编写。采用即时编译，直接翻译成机器语言，并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript 程序在 V8 引擎下的运行速度媲美二进制程序。</li><li>V8 内存设限：这么设限为了浏览器使用内存足够，内部还有垃圾运行机制，时间也在用户感知的合理范围 <ul><li>64bit 操作系统上不超过 1.5G</li><li>32bit 操作系统上不超过 800M</li></ul></li></ul><ol><li>64 位下是 1.4G</li><li>32 位下 700MB</li><li>根据浏览器不同会有些许的扩容 node 情况下会有 C++内存扩容</li></ol><p>设限原因：</p><ul><li>1.4G 对于浏览器脚本来说足够使用</li><li>回收是阻塞式的 垃圾回收会中断代码的执行 必须要限制</li></ul><p>这么设限为了浏览器使用内存足够，内部还有垃圾运行机制，时间也在用户感知的合理范围</p><h2 id="v8-垃圾回收策略" tabindex="-1">V8 垃圾回收策略 <a class="header-anchor" href="#v8-垃圾回收策略" aria-label="Permalink to &quot;V8 垃圾回收策略&quot;">​</a></h2><p>程序的使用过程中，可以分为 <strong>原始类型数据</strong> 和 <strong>对象类型数据</strong> 。 原始数据都是由程序语言自身控制的，这里的回收还是指<strong>主要存活在堆区的对象数据</strong>，这个过程是离不开内存操作的，V8 也是对内存做了上限，那在这种情况下是如何对垃圾进行回收的?</p><ul><li>采用分代回收的思想</li><li>内存分为新生代存储区、老生代存储区</li><li>针对不同代采用不同的算法</li></ul><p>所以 V8 中会用到更多的 GC 算法，这里对 GC 算法不懂的还有这篇文章中说到的标记清除、整理等算法详细<a href="https://segmentfault.com/a/1190000038461201" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000038461201</a></p><h2 id="v8-常用的-gc-算法" tabindex="-1">V8 常用的 GC 算法 <a class="header-anchor" href="#v8-常用的-gc-算法" aria-label="Permalink to &quot;V8 常用的 GC 算法&quot;">​</a></h2><ul><li>分代回收 (一定会用)</li><li>空间复制</li><li>标记清除</li><li>标记整理</li><li>标记增量 (提高效率用)</li></ul><h2 id="v8-的分代回收" tabindex="-1">V8 的分代回收 <a class="header-anchor" href="#v8-的分代回收" aria-label="Permalink to &quot;V8 的分代回收&quot;">​</a></h2><ul><li><strong>新生代</strong> —— 就是指存活时间较短的对象，例如：一个局部作用域中，只要函数执行完毕之后变量就会回收。</li><li><strong>老生代</strong> —— 就是指存活时间较长的对象，例如：全局对象，闭包变量数据。</li></ul><h3 id="v8-的内存分配" tabindex="-1">V8 的内存分配 <a class="header-anchor" href="#v8-的内存分配" aria-label="Permalink to &quot;V8 的内存分配&quot;">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/292785/1638257448458-eceb0f05-b280-4e4f-bd6b-e6c9aa7278be.png#clientId=u0af62612-21ca-4&amp;from=paste&amp;height=274&amp;id=u183bca8e&amp;name=image.png&amp;originHeight=548&amp;originWidth=2308&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=320893&amp;status=done&amp;style=none&amp;taskId=uc2f18846-c5bc-4d42-bc9d-90aec2fb926&amp;title=&amp;width=1154" alt="image.png"></p><ul><li>左边小空间用于存储新生代对象 <ul><li>64bit 操作系统上不超过 32M</li><li>32bit 操作系统上不超过 16M</li></ul></li><li>右边较大空间用于存储老生代对象 <ul><li>64bit 操作系统上不超过 1.6G</li><li>32bit 操作系统上不超过 700M</li></ul></li></ul><h3 id="新生代对象回收" tabindex="-1">新生代对象回收 <a class="header-anchor" href="#新生代对象回收" aria-label="Permalink to &quot;新生代对象回收&quot;">​</a></h3><h4 id="主要使用算法" tabindex="-1">主要使用算法 <a class="header-anchor" href="#主要使用算法" aria-label="Permalink to &quot;主要使用算法&quot;">​</a></h4><p>采用赋值算法 + 标记整理算法</p><h4 id="回收过程" tabindex="-1">回收过程 <a class="header-anchor" href="#回收过程" aria-label="Permalink to &quot;回收过程&quot;">​</a></h4><p>新生代内存区分为两个等大小空间，使用空间为 From，空闲空间为 To。 如果需要申请空间使用，回收步骤如下：</p><ol><li>首先会将所有活动对象存储于 From 空间，这个过程中 To 是空闲状态。</li><li>当 From 空间使用到一定程度之后就会触发 GC 操作，这个时候会进行标记整理对活动对象进行标记并移动位置将使用空间变得连续，便于后续不会产生碎片化空间。</li><li>将活动对象拷贝至 To 空间，拷贝完成之后活动空间就有了备份，这个时候就可以考虑回收操作了。</li><li>把 From 空间完成释放，回收完成</li><li>对 From 和 To 名称进行调换，继续重复之前的操作。</li></ol><p>总结就是： 使用 From -&gt; 触发 GC 标记整理 -&gt; 拷贝到 To -&gt; 回收 From -&gt; 名称互换重复之前</p><h4 id="晋升" tabindex="-1">晋升 <a class="header-anchor" href="#晋升" aria-label="Permalink to &quot;晋升&quot;">​</a></h4><p>拷贝的过程中某个对象的指代在老生代空间，就可能出现晋升。 <strong>晋升就是将新生代对象移动至老生代。</strong><strong>什么时候触发晋升操作?</strong></p><ol><li>一轮 GC 之后还存活的新生代对象需要晋升</li><li>在拷贝过程中，To 空间的使用率超过 25%，将这次的活动对象都移动至老生代空间</li></ol><p><strong>为什么是限制 To 的使用率呢?</strong> 将来回收操作是要把 From 空间的内容拷贝到 To 空间中进行交换，如果 To 的使用率太高，变成 From 之后新的对象就存不进去了。</p><h3 id="老生代对象回收" tabindex="-1">老生代对象回收 <a class="header-anchor" href="#老生代对象回收" aria-label="Permalink to &quot;老生代对象回收&quot;">​</a></h3><h4 id="主要使用算法-1" tabindex="-1">主要使用算法 <a class="header-anchor" href="#主要使用算法-1" aria-label="Permalink to &quot;主要使用算法&quot;">​</a></h4><p>主要采用标记清除 <strong>（首要）</strong> 、标记整理、增量标记算法</p><ul><li>标记清除：虽然使用标记清除会有空间碎片化的问题，但是标记清除提升的速度是很快的。</li><li>标记整理：在晋升的时候且老生代区域的空间也不够容纳的时候，就会采用标记整理进行 <strong>空间优化</strong>。</li><li>增量标记：将一整段的垃圾回收操作标记拆分成多个小段完成回收，主要是为了实现程序和垃圾回收的交替完成，这样进行 <strong>效率优化</strong> 带来的时间消耗更加的合理。</li></ul><p>之前标记清除和整理的原理都在 GC 那篇文章中解释，这里就详情看看增量标记是如何工作的?</p><h4 id="标记增量如何优化垃圾回收" tabindex="-1">标记增量如何优化垃圾回收? <a class="header-anchor" href="#标记增量如何优化垃圾回收" aria-label="Permalink to &quot;标记增量如何优化垃圾回收?&quot;">​</a></h4><p>看图可以将垃圾回收分成两个部分，一个是程序的执行，一个是垃圾的回收。当垃圾回收的时候其实会阻塞程序的执行，所以中间会有空档期。 <img src="https://cdn.nlark.com/yuque/0/2021/png/292785/1638257651837-6e2f8a66-208d-4f6c-9d13-49c10b1556b3.png#clientId=u0af62612-21ca-4&amp;from=paste&amp;height=428&amp;id=u1036ae48&amp;name=image.png&amp;originHeight=856&amp;originWidth=2622&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=802551&amp;status=done&amp;style=none&amp;taskId=ufaf952d9-f6c3-47e1-ae1c-5b2e9854af0&amp;title=&amp;width=1311" alt="image.png"></p><h3 id="新生代-vs-老生代" tabindex="-1">新生代 VS 老生代 <a class="header-anchor" href="#新生代-vs-老生代" aria-label="Permalink to &quot;新生代 VS 老生代&quot;">​</a></h3><ul><li>新生代区域垃圾回收使用<strong>空间换时间</strong><ul><li>主要采用复制算法，要有空闲空间存在，当然新生代本身空间小，分出来的复制的空间更小，所以浪费这点空间换取时间的效率是微不足道的</li></ul></li><li>老生代区域垃圾回收不适合复制算法，老生代空间大一分为二，会造成一半的空间浪费，存放数据多复制时间长。</li></ul><h2 id="什么时候触发-cg" tabindex="-1">什么时候触发 CG <a class="header-anchor" href="#什么时候触发-cg" aria-label="Permalink to &quot;什么时候触发 CG&quot;">​</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/292785/1638258615854-45b25718-1860-419f-8d7b-6bc865c5b88b.png#clientId=u0af62612-21ca-4&amp;from=paste&amp;height=493&amp;id=u3df3037f&amp;name=image.png&amp;originHeight=986&amp;originWidth=2238&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=806151&amp;status=done&amp;style=none&amp;taskId=u1e67a85a-f0ec-4e46-af44-07d99224d63&amp;title=&amp;width=1119" alt="image.png"> ps：全局变量程序执行完才会被回收 局部变量失去引用的时候会被回收</p><h2 id="优化内存" tabindex="-1">优化内存 <a class="header-anchor" href="#优化内存" aria-label="Permalink to &quot;优化内存&quot;">​</a></h2><h3 id="查看内存" tabindex="-1">查看内存 <a class="header-anchor" href="#查看内存" aria-label="Permalink to &quot;查看内存&quot;">​</a></h3><ul><li>web window.performance.memory</li><li>node process.memoryUsage()</li></ul><h3 id="优化建议" tabindex="-1">优化建议 <a class="header-anchor" href="#优化建议" aria-label="Permalink to &quot;优化建议&quot;">​</a></h3><ul><li>尽量不要定义全局变量 定义需要手动释放 a = null // a = undefined</li><li>注意闭包</li></ul><p>传统的浏览器里面 垃圾回收是自动的 node 可以手动触发垃圾回收 global.gc node 端可以设置内存 node --max-old-space-size=1700 test.js</p>',57),n=[o];function r(p,m,s,h,d,c){return e(),i("div",null,n)}const b=a(l,[["render",r]]);export{g as __pageData,b as default};
